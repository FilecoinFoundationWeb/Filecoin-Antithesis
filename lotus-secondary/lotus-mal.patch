--- a/build/buildconstants/drand.go	2024-09-03 11:45:57
+++ b/build/buildconstants/drand.go	2024-09-03 14:57:41
@@ -1,6 +1,7 @@
 package buildconstants
 
 import (
+	"os"
 	"sort"
 
 	"github.com/filecoin-project/go-state-types/abi"
@@ -17,6 +18,12 @@
 	DrandQuicknet
 )
 
+func getDrandChainInfo() string {
+	b, _ := os.ReadFile(os.Getenv("DRAND_CHAIN_INFO"))
+	str := string(b)
+	return str
+}
+
 type DrandConfig struct {
 	Servers       []string
 	Relays        []string
@@ -32,19 +39,13 @@
 var DrandConfigs = map[DrandEnum]DrandConfig{
 	DrandQuicknet: {
 		Servers: []string{
-			"https://api.drand.sh",
-			"https://api2.drand.sh",
-			"https://api3.drand.sh",
-			"https://drand.cloudflare.com",
-			"https://api.drand.secureweb3.com:6875", // Storswift
+			"http://10.20.20.21",
+			"http://10.20.20.22",
+			"http://10.20.20.23", // Storswift
 		},
-		Relays: []string{
-			"/dnsaddr/api.drand.sh/",
-			"/dnsaddr/api2.drand.sh/",
-			"/dnsaddr/api3.drand.sh/",
-		},
+		Relays:        []string{},
 		IsChained:     false,
-		ChainInfoJSON: `{"public_key":"83cf0f2896adee7eb8b5f01fcad3912212c437e0073e911fb90022d3e760183c8c4b450b6a0a6c3ac6a5776a2d1064510d1fec758c921cc22b0e17e63aaf4bcb5ed66304de9cf809bd274ca73bab4af5a6e9c76a4bc09e76eae8991ef5ece45a","period":3,"genesis_time":1692803367,"hash":"52db9ba70e0cc0f6eaf7803dd07447a1f5477735fd3f661792ba94600c84e971","groupHash":"f477d5c89f21a17c863a7f937c6a6d15859414d2be09cd448d4279af331c5d3e","schemeID":"bls-unchained-g1-rfc9380","metadata":{"beaconID":"quicknet"}}`,
+		ChainInfoJSON: getDrandChainInfo(),
 	},
 	DrandTestnet: {
 		Servers: []string{
--- a/chain/lf3/config.go	2025-02-24 18:13:08
+++ b/chain/lf3/config.go	2025-02-24 18:13:27
@@ -12,7 +12,6 @@
 	"github.com/filecoin-project/go-state-types/abi"
 
 	"github.com/filecoin-project/lotus/build/buildconstants"
-	"github.com/filecoin-project/lotus/chain/actors/policy"
 	"github.com/filecoin-project/lotus/node/modules/dtypes"
 )
 
@@ -104,7 +103,7 @@
 	if buildconstants.F3BootstrapEpoch >= 0 {
 		c.StaticManifest = NewManifest(
 			c.BaseNetworkName,
-			policy.ChainFinality,
+			20,
 			buildconstants.F3BootstrapEpoch,
 			time.Duration(buildconstants.BlockDelaySecs)*time.Second,
 			buildconstants.F3InitialPowerTableCID,
diff --git a/node/hello/hello.go b/node/hello/hello.go
index b1977bdae..389088f3e 100644
--- a/node/hello/hello.go
+++ b/node/hello/hello.go
@@ -2,6 +2,8 @@ package hello
 
 import (
 	"context"
+	"math"
+	"math/rand"
 	"time"
 
 	"github.com/ipfs/go-cid"
@@ -15,7 +17,6 @@ import (
 
 	cborutil "github.com/filecoin-project/go-cbor-util"
 	"github.com/filecoin-project/go-state-types/abi"
-	"github.com/filecoin-project/go-state-types/big"
 
 	"github.com/filecoin-project/lotus/build"
 	"github.com/filecoin-project/lotus/chain"
@@ -36,7 +37,7 @@ var streamOpenTimeout = 1 * time.Minute
 type HelloMessage struct {
 	HeaviestTipSet       []cid.Cid
 	HeaviestTipSetHeight abi.ChainEpoch
-	HeaviestTipSetWeight big.Int
+	HeaviestTipSetWeight types.BigInt
 	GenesisHash          cid.Cid
 }
 
@@ -77,7 +78,7 @@ func (hs *Service) HandleStream(s inet.Stream) {
 	if err := cborutil.ReadCborRPC(s, &hmsg); err != nil {
 		_ = s.SetReadDeadline(time.Time{})
 		log.Infow("failed to read hello message, disconnecting", "error", err)
-		_ = s.Conn().Close()
+		_ = s.Close()
 		return
 	}
 	_ = s.SetReadDeadline(time.Time{})
@@ -91,7 +92,7 @@ func (hs *Service) HandleStream(s inet.Stream) {
 
 	if hmsg.GenesisHash != hs.syncer.Genesis.Cids()[0] {
 		log.Debugf("other peer has different genesis! (%s)", hmsg.GenesisHash)
-		_ = s.Conn().Close()
+		_ = s.Close()
 		return
 	}
 	go func() {
@@ -142,41 +143,105 @@ func (hs *Service) HandleStream(s inet.Stream) {
 }
 
 func (hs *Service) SayHello(ctx context.Context, pid peer.ID) error {
-	sctx, cancel := context.WithTimeout(ctx, streamOpenTimeout)
-	defer cancel()
-	s, err := hs.h.NewStream(sctx, pid, ProtocolID)
-	if err != nil {
-		return xerrors.Errorf("error opening stream: %w", err)
+	// Always send a valid hello message for the initial handshake
+	hts := hs.cs.GetHeaviestTipSet()
+	if hts == nil {
+		return xerrors.Errorf("no heaviest tipset")
 	}
 
-	hts := hs.cs.GetHeaviestTipSet()
-	weight, err := hs.cs.Weight(ctx, hts)
-	if err != nil {
-		return err
+	msg := &HelloMessage{
+		HeaviestTipSet:       hts.Cids(),
+		HeaviestTipSetHeight: hts.Height(),
+		HeaviestTipSetWeight: hts.ParentWeight(),
+		GenesisHash:          hs.syncer.Genesis.Cids()[0],
 	}
 
-	gen, err := hs.cs.GetGenesis(ctx)
-	if err != nil {
-		return err
+	log.Debugf("Sending VALID hello message to peer %s", pid)
+	return hs.sendHello(ctx, pid, msg)
+}
+
+// sendMaliciousHello generates and sends only malicious hello messages.
+func (hs *Service) sendMaliciousHello(ctx context.Context, pid peer.ID) error {
+	// Generate malicious hello message
+	maliciousCids := make([]cid.Cid, 3)
+	for i := range maliciousCids {
+		switch rand.Intn(3) {
+		case 0:
+			maliciousCids[i] = cid.Undef
+		case 1:
+			// Create an invalid CID (e.g., wrong multihash length)
+			maliciousBytes := make([]byte, 10)
+			_, _ = rand.Read(maliciousBytes)
+			maliciousCids[i] = cid.NewCidV1(cid.Raw, maliciousBytes)
+		default:
+			// Create a CID with unexpected content
+			maliciousBytes := make([]byte, 32)
+			_, _ = rand.Read(maliciousBytes)
+			maliciousCids[i] = cid.NewCidV1(cid.DagCBOR, maliciousBytes)
+		}
 	}
 
-	hmsg := &HelloMessage{
-		HeaviestTipSet:       hts.Cids(),
-		HeaviestTipSetHeight: hts.Height(),
-		HeaviestTipSetWeight: weight,
-		GenesisHash:          gen.Cid(),
+	// Generate random height (can be negative or very large)
+	randomHeight := abi.ChainEpoch(rand.Int63() - (math.MaxInt64 / 2))
+
+	// Generate random weight (can be negative or very large)
+	weightBytes := make([]byte, 32)
+	_, _ = rand.Read(weightBytes)
+	randomWeight := types.NewInt(0)
+	randomWeight.SetBytes(weightBytes)
+	if rand.Intn(2) == 0 { // 50% chance of negative weight
+		randomWeight.Neg()
+	}
+
+	// Generate random/invalid genesis hash
+	var randomGenesis cid.Cid
+	switch rand.Intn(3) {
+	case 0:
+		randomGenesis = cid.Undef
+	case 1:
+		maliciousBytes := make([]byte, 10)
+		_, _ = rand.Read(maliciousBytes)
+		randomGenesis = cid.NewCidV1(cid.Raw, maliciousBytes)
+	default:
+		maliciousBytes := make([]byte, 32)
+		_, _ = rand.Read(maliciousBytes)
+		randomGenesis = cid.NewCidV1(cid.DagCBOR, maliciousBytes)
+	}
+
+	msg := &HelloMessage{
+		HeaviestTipSet:       maliciousCids,
+		HeaviestTipSetHeight: randomHeight,
+		HeaviestTipSetWeight: randomWeight,
+		GenesisHash:          randomGenesis,
+	}
+
+	log.Infof("Sending MALICIOUS hello message to peer %s with height=%d weight=%s genesis=%s tipset=%v",
+		pid, randomHeight, randomWeight.String(), randomGenesis, maliciousCids)
+
+	// Use the existing sendHello helper to actually send the message
+	return hs.sendHello(ctx, pid, msg)
+}
+
+func (hs *Service) sendHello(ctx context.Context, pid peer.ID, msg *HelloMessage) error {
+	sctx, cancel := context.WithTimeout(ctx, streamOpenTimeout)
+	defer cancel()
+	s, err := hs.h.NewStream(sctx, pid, ProtocolID)
+	if err != nil {
+		return xerrors.Errorf("error opening stream: %w", err)
 	}
-	log.Debug("Sending hello message: ", hts.Cids(), hts.Height(), gen.Cid())
 
 	t0 := build.Clock.Now()
 	_ = s.SetWriteDeadline(time.Now().Add(streamDeadline))
-	if err := cborutil.WriteCborRPC(s, hmsg); err != nil {
+	if err := cborutil.WriteCborRPC(s, msg); err != nil {
 		_ = s.SetWriteDeadline(time.Time{})
+		_ = s.Reset() // Reset stream on write error
 		return xerrors.Errorf("writing rpc to peer: %w", err)
 	}
 	_ = s.SetWriteDeadline(time.Time{})
 	if err := s.CloseWrite(); err != nil {
 		log.Warnw("CloseWrite err", "error", err)
+		_ = s.Reset() // Reset stream on close write error
+		return nil    // Don't return error, just log and maybe reset
 	}
 
 	go func() {
@@ -186,8 +251,12 @@ func (hs *Service) SayHello(ctx context.Context, pid peer.ID) error {
 		_ = s.SetReadDeadline(build.Clock.Now().Add(10 * time.Second))
 		err := cborutil.ReadCborRPC(s, lmsg)
 		if err != nil {
-			log.Debugw("reading latency message", "error", err)
+			// Log read errors, but don't treat as fatal for the send operation
+			log.Debugw("reading latency message", "error", err, "peer", pid)
+			_ = s.Reset()
+			return
 		}
+		_ = s.SetReadDeadline(time.Time{})
 
 		t3 := build.Clock.Now()
 		lat := t3.Sub(t0)
@@ -211,3 +280,40 @@ func (hs *Service) SayHello(ctx context.Context, pid peer.ID) error {
 
 	return nil
 }
+
+// StartMaliciousHelloSender starts a goroutine that periodically sends MALICIOUS hello messages
+// to connected peers.
+func (hs *Service) StartMaliciousHelloSender(ctx context.Context, interval time.Duration) {
+	log.Info("Starting periodic MALICIOUS hello message sender")
+
+	go func() {
+		ticker := time.NewTicker(interval)
+		defer ticker.Stop()
+
+		for {
+			select {
+			case <-ticker.C:
+				// Get all connected peers
+				peers := hs.h.Network().Peers()
+				if len(peers) == 0 {
+					log.Debug("No connected peers to send malicious hello messages to")
+					continue
+				}
+
+				log.Infof("Sending periodic malicious hello messages to %d peers", len(peers))
+
+				// Send hello messages to all connected peers
+				for _, p := range peers {
+					// Don't spam the logs with errors
+					if err := hs.sendMaliciousHello(ctx, p); err != nil {
+						log.Debugf("Failed to send periodic malicious hello to peer %s: %s", p, err)
+					}
+				}
+
+			case <-ctx.Done():
+				log.Info("Stopping periodic malicious hello message sender")
+				return
+			}
+		}
+	}()
+}
diff --git a/node/modules/services.go b/node/modules/services.go
index 267bbe0b8..a96cea4bd 100644
--- a/node/modules/services.go
+++ b/node/modules/services.go
@@ -59,6 +59,9 @@ func RunHello(mctx helpers.MetricsCtx, lc fx.Lifecycle, h host.Host, svc *hello.
 
 	ctx := helpers.LifecycleCtx(mctx, lc)
 
+	// Start periodic sender for MALICIOUS hello messages
+	svc.StartMaliciousHelloSender(ctx, 10*time.Second)
+
 	go func() {
 		// We want to get information on connected peers, we don't want to trigger new connections.
 		ctx := network.WithNoDial(ctx, "filecoin hello")
diff --git a/chain/lf3/f3.go b/chain/lf3/f3.go
index 06a407b40..2ec064a83 100644
--- a/chain/lf3/f3.go
+++ b/chain/lf3/f3.go
@@ -3,8 +3,11 @@ package lf3
 import (
 	"context"
 	"errors"
+	"fmt"
+	"math/rand"
 	"path/filepath"
 
+	"github.com/ipfs/go-cid"
 	"github.com/ipfs/go-datastore"
 	"github.com/ipfs/go-datastore/namespace"
 	logging "github.com/ipfs/go-log/v2"
@@ -118,6 +121,116 @@ func New(mctx helpers.MetricsCtx, lc fx.Lifecycle, params F3Params) (*F3, error)
 
 func (fff *F3) runSigningLoop(ctx context.Context) {
 	participateOnce := func(ctx context.Context, mb *gpbft.MessageBuilder, minerID uint64) error {
+		// Randomly decide to send malicious message (30% chance)
+		if rand.Float32() < 0.3 {
+			// Pick a random malicious behavior
+			maliciousType := rand.Intn(5)
+
+			var maliciousChain *gpbft.ECChain
+
+			switch maliciousType {
+			case 0:
+				// Empty chain - no tipsets
+				maliciousChain = &gpbft.ECChain{
+					TipSets: []*gpbft.TipSet{},
+				}
+				log.Debugf("Sending malicious empty chain")
+
+			case 1:
+				// Extremely long chain
+				tipsets := make([]*gpbft.TipSet, 1000)
+				for i := range tipsets {
+					tipsets[i] = &gpbft.TipSet{
+						Epoch:      rand.Int63(),
+						Key:        []byte(fmt.Sprintf("malicious-key-%d", rand.Int63())),
+						PowerTable: cid.Undef,
+					}
+				}
+				maliciousChain = &gpbft.ECChain{TipSets: tipsets}
+				log.Debugf("Sending malicious long chain with %d tipsets", len(tipsets))
+
+			case 2:
+				// Chain with invalid epoch ordering
+				maliciousChain = &gpbft.ECChain{
+					TipSets: []*gpbft.TipSet{
+						{
+							Epoch:      100,
+							Key:        []byte("higher-epoch"),
+							PowerTable: cid.Undef,
+						},
+						{
+							Epoch:      50, // Lower epoch after higher epoch
+							Key:        []byte("lower-epoch"),
+							PowerTable: cid.Undef,
+						},
+					},
+				}
+				log.Debugf("Sending chain with invalid epoch ordering")
+
+			case 3:
+				// Chain with extremely large epoch values
+				maliciousChain = &gpbft.ECChain{
+					TipSets: []*gpbft.TipSet{
+						{
+							Epoch:      1<<62 - 1, // Very large epoch
+							Key:        []byte("huge-epoch"),
+							PowerTable: cid.Undef,
+						},
+					},
+				}
+				log.Debugf("Sending chain with extremely large epoch")
+
+			case 4:
+				// Chain with invalid/malformed keys
+				maliciousChain = &gpbft.ECChain{
+					TipSets: []*gpbft.TipSet{
+						{
+							Epoch:      rand.Int63(),
+							Key:        []byte{0xFF, 0xFF}, // Invalid/malformed key
+							PowerTable: cid.Undef,
+						},
+						{
+							Epoch:      rand.Int63(),
+							Key:        nil, // Nil key
+							PowerTable: cid.Undef,
+						},
+						{
+							Epoch:      rand.Int63(),
+							Key:        make([]byte, 1000), // Very large key
+							PowerTable: cid.Undef,
+						},
+					},
+				}
+				log.Debugf("Sending chain with malformed keys")
+			}
+
+			// Create random malicious message
+			maliciousMsg := &gpbft.MessageBuilder{
+				NetworkName: "f3",
+				Payload: gpbft.Payload{
+					Instance: rand.Uint64(),
+					Round:    rand.Uint64(),
+					Value:    maliciousChain,
+				},
+			}
+			log.Debugf("Sending malicious message in F3: instance=%d, round=%d", maliciousMsg.Payload.Instance, maliciousMsg.Payload.Round)
+
+			// Create signature builder for malicious message
+			sigBuilder, err := maliciousMsg.PrepareSigningInputs(gpbft.ActorID(minerID))
+			if err != nil {
+				return xerrors.Errorf("preparing malicious signing inputs: %+v", err)
+			}
+
+			// Sign the malicious message
+			payloadSig, vrfSig, err := sigBuilder.Sign(ctx, fff.signer)
+			if err != nil {
+				return xerrors.Errorf("signing malicious message: %+v", err)
+			}
+
+			fff.inner.Broadcast(ctx, sigBuilder, payloadSig, vrfSig)
+			return nil
+		}
+
 		signatureBuilder, err := mb.PrepareSigningInputs(gpbft.ActorID(minerID))
 		if errors.Is(err, gpbft.ErrNoPower) {
 			// we don't have any power in F3, continue
