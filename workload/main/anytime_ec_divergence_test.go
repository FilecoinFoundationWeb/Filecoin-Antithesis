package main

import (
	"math"
	"testing"
	"time"

	"github.com/filecoin-project/go-f3/gpbft"
	"github.com/filecoin-project/go-f3/sim"
	"github.com/filecoin-project/go-f3/sim/latency"
	"github.com/stretchr/testify/require"
)

const (
	maxRounds            = 10
	latencyAsync         = 100 * time.Millisecond
	EcEpochDuration      = 30 * time.Second
	EcStabilisationDelay = 3 * time.Second
)

var (
	oneStoragePower        = gpbft.NewStoragePower(1)
	uniformOneStoragePower = sim.UniformStoragePower(oneStoragePower)
	testGpbftOptions       = []gpbft.Option{
		gpbft.WithDelta(200 * time.Millisecond),
		gpbft.WithDeltaBackOffExponent(1.300),
		gpbft.WithRebroadcastBackoff(1.3, 0, time.Second, 5*time.Second),
	}
)

func syncOptions(o ...sim.Option) []sim.Option {
	return append(o,
		sim.WithLatencyModeler(func() (latency.Model, error) { return latency.None, nil }),
		sim.WithECEpochDuration(EcEpochDuration),
		sim.WitECStabilisationDelay(EcStabilisationDelay),
		sim.WithGpbftOptions(testGpbftOptions...),
	)
}

func asyncOptions(latencySeed int, o ...sim.Option) []sim.Option {
	return append(o,
		sim.WithLatencyModeler(func() (latency.Model, error) {
			return latency.NewLogNormal(int64(latencySeed), latencyAsync), nil
		}),
		sim.WithECEpochDuration(EcEpochDuration),
		sim.WitECStabilisationDelay(EcStabilisationDelay),
		sim.WithGpbftOptions(testGpbftOptions...),
	)
}

func requireConsensusAtInstance(t *testing.T, sm *sim.Simulation, instance uint64, expectAnyOf ...gpbft.TipSet) {
	t.Helper()
	inst := sm.GetInstance(instance)
	for _, pid := range sm.ListParticipantIDs() {
		require.NotNil(t, inst, "no such instance")
		decision := inst.GetDecision(pid)
		require.NotNil(t, decision, "no decision for participant %d in instance %d", pid, instance)
		require.Contains(t, expectAnyOf, *decision.Head(), "consensus not reached: participant %d decided %s in instance %d, expected any of %s",
			pid, decision.Head(), instance, gpbft.ECChain(expectAnyOf))
	}
}

func TestEcDivergence_AbsoluteDivergenceConvergesOnBase(t *testing.T) {

	const (
		instanceCount     = 14
		divergeAtInstance = 9
	)

	tests := []struct {
		name    string
		options []sim.Option
	}{
		{
			name:    "sync",
			options: syncOptions(),
		},
		{
			name:    "async",
			options: asyncOptions(985623),
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			t.Parallel()
			seedFuzzer := uint64(985623)

			// uniformECChainGenerator generates different EC chain per instance but the same
			// chain for all participants. i.e. with no divergence among votes.
			uniformECChainGenerator := sim.NewUniformECChainGenerator(17*seedFuzzer, 5, 10)

			// randomECChainGenerator generates different EC chain per instance per participant, i.e. total disagreement across the network.
			randomECChainGenerator := sim.NewRandomECChainGenerator(23*seedFuzzer, 5, 10)

			// divergeAfterECChainGenerator uses uniformECChainGenerator up until
			// divergeAtInstance and randomECChainGenerator after it. This simulates a
			// scenario where all participants initially propose the same chain at each
			// instance. But then totally diverge to propose different chains only sharing
			// the same base.
			divergeAfterECChainGenerator := &ecChainGeneratorSwitcher{
				switchAtInstance: divergeAtInstance,
				before:           uniformECChainGenerator,
				after:            randomECChainGenerator,
			}

			sm, err := sim.NewSimulation(
				append(test.options,
					sim.AddHonestParticipants(20, divergeAfterECChainGenerator, uniformOneStoragePower),
				)...)
			require.NoError(t, err)
			require.NoErrorf(t, sm.Run(instanceCount, maxRounds), "%s", sm.Describe())

			// Assert that every instance has reached consensus on the expected base chain,
			// where:
			// * before divergeAtInstance the decision must match the chain generated by
			// uniformECChainGenerator, and
			// * after it the decision must match the base of last decision made before
			// divergeAtInstance.
			//
			// Because:
			// * before divergeAtInstance, all nodes propose the same chain via
			// uniformECChainGenerator, and
			// * after it, every node proposes a chain (only sharing base tipset as required
			// by gPBFT)
			instance := sm.GetInstance(0)
			require.NotNil(t, instance, "instance 0")
			latestBaseECChain := instance.BaseChain
			for i := uint64(0); i < instanceCount; i++ {
				instance = sm.GetInstance(i + 1)
				require.NotNil(t, instance, "instance %d", i)

				var wantDecision gpbft.ECChain
				if i < divergeAtInstance {
					wantDecision = divergeAfterECChainGenerator.GenerateECChain(i, *latestBaseECChain.Head(), math.MaxUint64)
					// Sanity check that the chains generated are not the same but share the same
					// base.
					require.Equal(t, wantDecision.Base(), latestBaseECChain.Head())
					require.NotEqual(t, wantDecision.Suffix(), latestBaseECChain.Suffix())
				} else {
					// After divergeAtInstance all nodes propose different chains. Therefore, the
					// only agreeable chain is the base chain of instance before divergeAtInstance.
					wantDecision = latestBaseECChain
				}

				// Assert the consensus is reached at the head of expected chain.
				requireConsensusAtInstance(t, sm, i, *wantDecision.Head())
				latestBaseECChain = instance.BaseChain
			}
		})
	}
}

type ecChainGeneratorSwitcher struct {
	switchAtInstance uint64
	before           sim.ECChainGenerator
	after            sim.ECChainGenerator
}

func (d *ecChainGeneratorSwitcher) GenerateECChain(instance uint64, base gpbft.TipSet, id gpbft.ActorID) gpbft.ECChain {
	if instance < d.switchAtInstance {
		return d.before.GenerateECChain(instance, base, id)
	}
	return d.after.GenerateECChain(instance, base, id)
}
