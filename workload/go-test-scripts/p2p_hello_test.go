//go:build go1.18
// +build go1.18

package main

import (
	"context"
	"os"
	"testing"
	"time"

	"github.com/libp2p/go-libp2p"
	"github.com/libp2p/go-libp2p/core/peer"
	ma "github.com/multiformats/go-multiaddr"
)

const helloID = "/fil/hello/1.0.0"

// helloMsg is a sample valid hello message (serialized payload).
var helloMsg = []byte{
	0x84, 0x83, 0xd8, 0x2a, 0x58, 0x27, 0x00, 0x01, 0x71, 0xa0,
	0xe4, 0x02, 0x20, 0xab, 0xf8, 0x4e, 0xf8, 0xff, 0x64, 0x55,
	0x3f, 0x8f, 0x1d, 0x69, 0x81, 0x18, 0x1c, 0x3b, 0xe0, 0x84,
	0x89, 0x83, 0x19, 0xa4, 0xff, 0x97, 0xa7, 0x30, 0x14, 0xdf,
	0xcf, 0xe5, 0xad, 0xd5, 0xbd, 0xd8, 0x2a, 0x58, 0x27, 0x00,
	0x01, 0x71, 0xa0, 0xe4, 0x02, 0x20, 0x6f, 0xe5, 0x22, 0x40,
	0x16, 0x7c, 0x24, 0x3f, 0x94, 0xfb, 0xfa, 0x06, 0x5e, 0x62,
	0x78, 0xc1, 0xa5, 0x19, 0x84, 0x15, 0x6c, 0x76, 0xef, 0x7b,
	0xf6, 0xa6, 0x6b, 0x9a, 0x3e, 0x1e, 0xc6, 0x41, 0xd8, 0x2a,
	0x58, 0x27, 0x00, 0x01, 0x71, 0xa0, 0xe4, 0x02, 0x20, 0x76,
	0x49, 0xbd, 0x9a, 0xbb, 0x7b, 0x9f, 0x16, 0x5d, 0x9b, 0x61,
	0xb6, 0x36, 0x7e, 0xb6, 0x15, 0x7e, 0x34, 0x89, 0xd7, 0x7f,
	0xd4, 0xb8, 0x81, 0x66, 0x84, 0xcd, 0x38, 0x71, 0x4a, 0xc7,
	0xf9, 0x1a, 0x00, 0x39, 0x9e, 0x78, 0x46, 0x00, 0x14, 0xdc,
	0xc8, 0x35, 0xc1, 0xd8, 0x2a, 0x58, 0x27, 0x00, 0x01, 0x71,
	0xa0, 0xe4, 0x02, 0x20, 0x9a, 0x06, 0x40, 0xd0, 0x62, 0x0a,
	0xf5, 0xd1, 0xc4, 0x58, 0xef, 0xfc, 0xe4, 0xcb, 0xb8, 0x96,
	0x97, 0x79, 0xc9, 0x07, 0x2b, 0x16, 0x4d, 0x3f, 0xe6, 0xf5,
	0x17, 0x9d, 0x63, 0x78, 0xd8, 0xcd,
}

// FuzzHello sends fuzzed hello messages to the target peer.
// It seeds the corpus with a known valid helloMsg.
func FuzzHello(f *testing.F) {
	// Seed corpus with a valid hello message.
	f.Add(helloMsg)

	// Retrieve target multiaddress from the environment.
	target, ok := os.LookupEnv("LOTUS_TARGET")
	if !ok {
		f.Skip("LOTUS_TARGET environment variable not set")
	}

	// Parse the target multiaddress.
	targetMaddr, err := ma.NewMultiaddr(target)
	if err != nil {
		f.Skip("failed to parse LOTUS_TARGET multiaddr")
	}
	ai, err := peer.AddrInfoFromP2pAddr(targetMaddr)
	if err != nil {
		f.Skip("failed to extract peer info from LOTUS_TARGET multiaddr")
	}

	// Fuzz function: receives a fuzzed byte slice which is used as the hello payload.
	f.Fuzz(func(t *testing.T, data []byte) {
		ctx := context.Background()

		// Create a new libp2p host for this fuzz iteration.
		host, err := libp2p.New()
		if err != nil {
			t.Fatalf("failed to create libp2p host: %v", err)
		}
		defer host.Close()

		// Connect to the target peer.
		if err := host.Connect(ctx, *ai); err != nil {
			t.Skip("failed to connect to target peer: " + err.Error())
		}

		// Allow a brief moment for connection establishment.
		time.Sleep(100 * time.Millisecond)

		// Open a new stream using the hello protocol.
		stream, err := host.NewStream(ctx, ai.ID, helloID)
		if err != nil {
			t.Skip("failed to open stream: " + err.Error())
		}
		defer stream.Close()

		// Send the fuzzed payload.
		n, err := stream.Write(data)
		if err != nil {
			t.Errorf("failed to write fuzz data: %v", err)
		} else {
			t.Logf("Wrote %d bytes from fuzz input: %x", n, data)
		}

		// Close the write side of the stream.
		if err := stream.CloseWrite(); err != nil {
			t.Errorf("failed to close stream write: %v", err)
		}
	})
}
