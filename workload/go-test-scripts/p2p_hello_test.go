//go:build go1.18
// +build go1.18

package main

import (
	"context"
	"math/rand"
	"os"
	"strings"
	"testing"

	"github.com/libp2p/go-libp2p"
	"github.com/libp2p/go-libp2p/core/peer"
	ma "github.com/multiformats/go-multiaddr"
)

const helloID = "/fil/hello/1.0.0"

var helloMsg = []byte{
	0x84, 0x83, 0xd8, 0x2a, 0x58, 0x27, 0x00, 0x01, 0x71, 0xa0,
	0xe4, 0x02, 0x20, 0xab, 0xf8, 0x4e, 0xf8, 0xff, 0x64, 0x55,
	0x3f, 0x8f, 0x1d, 0x69, 0x81, 0x18, 0x1c, 0x3b, 0xe0, 0x84,
	0x89, 0x83, 0x19, 0xa4, 0xff, 0x97, 0xa7, 0x30, 0x14, 0xdf,
	0xcf, 0xe5, 0xad, 0xd5, 0xbd, 0xd8, 0x2a, 0x58, 0x27, 0x00,
	0x01, 0x71, 0xa0, 0xe4, 0x02, 0x20, 0x6f, 0xe5, 0x22, 0x40,
	0x16, 0x7c, 0x24, 0x3f, 0x94, 0xfb, 0xfa, 0x06, 0x5e, 0x62,
	0x78, 0xc1, 0xa5, 0x19, 0x84, 0x15, 0x6c, 0x76, 0xef, 0x7b,
	0xf6, 0xa6, 0x6b, 0x9a, 0x3e, 0x1e, 0xc6, 0x41, 0xd8, 0x2a,
	0x58, 0x27, 0x00, 0x01, 0x71, 0xa0, 0xe4, 0x02, 0x20, 0x76,
	0x49, 0xbd, 0x9a, 0xbb, 0x7b, 0x9f, 0x16, 0x5d, 0x9b, 0x61,
	0xb6, 0x36, 0x7e, 0xb6, 0x15, 0x7e, 0x34, 0x89, 0xd7, 0x7f,
	0xd4, 0xb8, 0x81, 0x66, 0x84, 0xcd, 0x38, 0x71, 0x4a, 0xc7,
	0xf9, 0x1a, 0x00, 0x39, 0x9e, 0x78, 0x46, 0x00, 0x14, 0xdc,
	0xc8, 0x35, 0xc1, 0xd8, 0x2a, 0x58, 0x27, 0x00, 0x01, 0x71,
	0xa0, 0xe4, 0x02, 0x20, 0x9a, 0x06, 0x40, 0xd0, 0x62, 0x0a,
	0xf5, 0xd1, 0xc4, 0x58, 0xef, 0xfc, 0xe4, 0xcb, 0xb8, 0x96,
	0x97, 0x79, 0xc9, 0x07, 0x2b, 0x16, 0x4d, 0x3f, 0xe6, 0xf5,
	0x17, 0x9d, 0x63, 0x78, 0xd8, 0xcd,
}

func mutateHelloMessage(b []byte) []byte {
	mutated := make([]byte, len(b))
	copy(mutated, b)
	switch rand.Intn(4) {
	case 0:
		if len(mutated) > 0 {
			newLen := rand.Intn(len(mutated))
			return mutated[:newLen]
		}
	case 1:
		extra := make([]byte, rand.Intn(10)+1)
		rand.Read(extra)
		return append(mutated, extra...)
	case 2:
		idx := rand.Intn(len(mutated))
		mutated[idx] ^= 0xFF
		return mutated
	case 3:
		pos := rand.Intn(len(mutated))
		return append(mutated[:pos], append([]byte{byte(rand.Intn(256))}, mutated[pos:]...)...)
	}
	return mutated
}

func FuzzHello(f *testing.F) {
	f.Add(helloMsg)

	target, ok := os.LookupEnv("LOTUS_TARGET")
	if !ok {
		f.Skip("LOTUS_TARGET environment variable not set")
	}
	targetMaddr, err := ma.NewMultiaddr(target)
	if err != nil {
		f.Skip("failed to parse LOTUS_TARGET multiaddr")
	}
	ai, err := peer.AddrInfoFromP2pAddr(targetMaddr)
	if err != nil {
		f.Skip("failed to extract peer info from LOTUS_TARGET multiaddr")
	}

	f.Fuzz(func(t *testing.T, data []byte) {
		defer func() {
			if r := recover(); r != nil {
				t.Logf("ðŸ’¥ Panic caught: %v", r)
				os.Exit(0) // exit fuzzing early without failing
			}
		}()

		ctx := context.Background()
		host, err := libp2p.New()
		if err != nil {
			t.Skipf("failed to create libp2p host: %v", err)
		}
		defer host.Close()

		if err := host.Connect(ctx, *ai); err != nil {
			t.Skipf("failed to connect: %v", err)
		}

		stream, err := host.NewStream(ctx, ai.ID, helloID)
		if err != nil {
			t.Skipf("failed to open stream: %v", err)
		}
		defer stream.Close()

		var payload []byte
		if len(data)%2 == 0 {
			payload = append(helloMsg, data...)
		} else {
			payload = mutateHelloMessage(helloMsg)
		}

		_, err = stream.Write(payload)
		if err != nil {
			t.Logf("stream write error: %v", err)

			// Kill fuzzing early if it's likely to cause panic/corruption
			if strings.Contains(err.Error(), "connection reset by peer") ||
				strings.Contains(err.Error(), "broken pipe") {
				t.Logf("Node likely crashed or dropped connection. Exiting early.")
				os.Exit(0)
			}
			return
		}

		if err := stream.CloseWrite(); err != nil {
			t.Logf("failed to close write: %v", err)
		}
	})
}
